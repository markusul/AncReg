[{"path":"http://www.markus-ulmer.ch/AncReg/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Christoph Schultheiss. Author. Markus Ulmer. Author, maintainer, copyright holder.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Schultheiss C, Ulmer M, B\"uhlmann P (2025). “Ancestor regression structural vector autoregressive models.” Journal Causal Inference, 13(1), 20240011. doi:10.1515/jci-2024-0011.","code":"@Article{,   title = {Ancestor regression in structural vector autoregressive models},   author = {Christoph Schultheiss and Markus Ulmer and Peter B{\"u}hlmann},   pages = {20240011},   volume = {13},   number = {1},   journal = {Journal of Causal Inference},   doi = {10.1515/jci-2024-0011},   year = {2025}, }"},{"path":"http://www.markus-ulmer.ch/AncReg/index.html","id":"ancestor-regression-","dir":"","previous_headings":"","what":"Ancestor Regression","title":"Ancestor Regression","text":"Ancestor Regression (AncReg) package methods test ancestral connections linear structural equation models (C. Schultheiss Bühlmann (2023)) structural vector autoregressive models (Christoph Schultheiss, Ulmer, Bühlmann (2025)). Ancestor Regression provides explicit error control false causal discovery, least asymptotically. power, however, relies non-Gaussian distributions.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Ancestor Regression","text":"install Ancestor Regression R package CRAN, just run can install development version AncReg GitHub : ","code":"install.packages(AncReg) # install.packages(\"devtools\") devtools::install_github(\"markusul/AncReg\") # install.packages('pak') pak::pkg_install('markusul/AncReg')"},{"path":"http://www.markus-ulmer.ch/AncReg/index.html","id":"linear-structural-equation-models","dir":"","previous_headings":"","what":"linear structural equation models","title":"Ancestor Regression","text":"basic example use Ancestor Regression using simulated data. summary function can used collect organize p-values. Additionally returns estimated ancestral graphs. know truth simulated model, can compare estimated ancestral graph true one.","code":"library(AncReg)  # random DAGS for simulation set.seed(42)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # solution in terms of noise Bprime <- MASS::ginv(diag(p) - B)  n <- 5000 N <- matrix(rexp(n * p), ncol = p) X <- t(Bprime %*% t(N)) colnames(X) <- LETTERS[1:p]  # fit Ancestor Regression fit <- AncReg(X) #> Registered S3 method overwritten by 'quantmod': #>   method            from #>   as.zoo.data.frame zoo fit #> $z.val #>          A.0        B.0        C.0        D.0        E.0 #> A 48.7380204  0.2228364 -0.8016602  0.5490716 -0.4341680 #> B -5.3286343 59.1036440 -1.2511824 -1.2682775  0.4165155 #> C -4.5000966 -8.4766371 53.2254962  0.1683882  1.9111938 #> D -5.0924716 -0.8902521 -1.0268923 75.1415659  0.8641796 #> E -0.2529153 -3.8052342 -1.0547642  1.8153614 61.9014974 #>  #> $p.val #>            A.0          B.0       C.0        D.0        E.0 #> A 0.000000e+00 8.236628e-01 0.4227496 0.58295633 0.66416645 #> B 9.895400e-08 0.000000e+00 0.2108679 0.20469888 0.67703283 #> C 6.792260e-06 2.317966e-17 0.0000000 0.86627792 0.05597968 #> D 3.534257e-07 3.733305e-01 0.3044712 0.00000000 0.38748922 #> E 8.003337e-01 1.416701e-04 0.2915332 0.06946839 0.00000000 #>  #> attr(,\"class\") #> [1] \"AncReg\" # collect ancestral p-values and graph res <- summary(fit) res #> $p.val #>              A            B         C          D          E #> A 1.000000e+00 8.236628e-01 0.4227496 0.58295633 0.66416645 #> B 9.895400e-08 1.000000e+00 0.2108679 0.20469888 0.67703283 #> C 6.792260e-06 2.317966e-17 1.0000000 0.86627792 0.05597968 #> D 3.534257e-07 3.733305e-01 0.3044712 1.00000000 0.38748922 #> E 8.003337e-01 1.416701e-04 0.2915332 0.06946839 1.00000000 #>  #> $graph #>       A     B     C     D     E #> A FALSE FALSE FALSE FALSE FALSE #> B  TRUE FALSE FALSE FALSE FALSE #> C  TRUE  TRUE FALSE FALSE FALSE #> D  TRUE FALSE FALSE FALSE FALSE #> E  TRUE  TRUE FALSE FALSE FALSE #>  #> $alpha #> [1] 0.05 #>  #> attr(,\"class\") #> [1] \"summary.AncReg\" #compare true and estimated ancestral graph trueGraph <- igraph::graph_from_adjacency_matrix(recAncestor(B != 0)) ancGraph <- igraph::graph_from_adjacency_matrix(res$graph)  #same layout for both graphs l <- igraph::layout_as_tree(trueGraph)   par(mfrow = c(1, 2)) plot(trueGraph, main = 'true ancestral graph', vertex.size = 30, layout = l) plot(ancGraph, main = 'Ancestor Regression', vertex.size = 30, layout = l)"},{"path":"http://www.markus-ulmer.ch/AncReg/index.html","id":"structural-vector-autoregressive-models","dir":"","previous_headings":"","what":"structural vector autoregressive models","title":"Ancestor Regression","text":"show example SVAR application using time series geyser eruptions. (Christoph Schultheiss, Ulmer, Bühlmann (2025))","code":"geyser <- MASS::geyser # shift waiting such that it is waiting after erruption geyser2 <- data.frame(waiting = geyser$waiting[-1], duration = geyser$duration[-nrow(geyser)])  # fit ancestor regression with 6 lags considered fit2 <- AncReg(as.matrix(geyser2), degree = 6) res2 <- summary(fit2) res2 #> $inst.p.val #>            waiting     duration #> waiting  1.0000000 0.0004811719 #> duration 0.5109396 1.0000000000 #>  #> $inst.graph #>          waiting duration #> waiting    FALSE     TRUE #> duration   FALSE    FALSE #>  #> $inst.alpha #> [1] 0.05 #>  #> $sum.p.val #>            waiting    duration #> waiting  1.0000000 0.008733271 #> duration 0.1760936 1.000000000 #>  #> $sum.graph #>          waiting duration #> waiting    FALSE     TRUE #> duration   FALSE    FALSE #>  #> attr(,\"class\") #> [1] \"summary.AncReg\"  par(mfrow = c(1, 2))  # visualize instantaneous ancestry instGraph <- igraph::graph_from_adjacency_matrix(res2$inst.graph) l <- igraph::layout_as_tree(instGraph)  plot(instGraph, edge.label = round(diag(res2$inst.p.val[1:2, 2:1]), 2),       main = 'instantaneous effects', vertex.size = 90, layout = l)  # visualize summary of lagged ancestry sumGraph <- igraph::graph_from_adjacency_matrix(res2$sum.graph) plot(sumGraph, edge.label = round(diag(res2$sum.p.val[1:2, 2:1]), 2),       main = 'summary graph', vertex.size = 90, layout = l)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/AncReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Ancestor Regression — AncReg","title":"Ancestor Regression — AncReg","text":"function performs ancestor regression linear structural equation models (Schultheiss et al. 2025)  vector autoregressive models (Schultheiss Bühlmann 2023)  explicit error control false discovery, least asymptomatically.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/AncReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ancestor Regression — AncReg","text":"","code":"AncReg(x, degree = 0, targets = colnames(x), f = function(x) x^3)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/AncReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ancestor Regression — AncReg","text":"x named numeric matrix containing observational data. degree integer specifying order SVAR process considered. Default 0 time series. targets character vector specifying variables whose ancestors estimated. Default variables. f function specifying non-linearity used ancestor regression. Default cubic function.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/AncReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ancestor Regression — AncReg","text":"object class \"AncReg\" containing: z.val numeric matrix test statistics. p.val numeric matrix p-values.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/AncReg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ancestor Regression — AncReg","text":"Schultheiss C, Bühlmann P (2023). “Ancestor regression linear structural equation models.” Biometrika, 110(4), 1117-1124. ISSN 1464-3510, doi:10.1093/biomet/asad008 , https://academic.oup.com/biomet/article-pdf/110/4/1117/53472115/asad008.pdf. Schultheiss C, Ulmer M, Bühlmann P (2025). “Ancestor regression structural vector autoregressive models.” doi:10.1515/jci-2024-0011 .","code":""},{"path":[]},{"path":"http://www.markus-ulmer.ch/AncReg/reference/AncReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ancestor Regression — AncReg","text":"","code":"##### simulated example for inear structural equation models  # random DAGS for simulation set.seed(1234)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # solution in terms of noise Bprime <- MASS::ginv(diag(p) - B)  n <- 5000 N <- matrix(rexp(n * p), ncol = p) X <- t(Bprime %*% t(N)) colnames(X) <- LETTERS[1:p]  # fit ancestor regression fit <- AncReg(X) #> Registered S3 method overwritten by 'quantmod': #>   method            from #>   as.zoo.data.frame zoo  # collect ancestral p-values and graph res <- summary(fit) res #> $p.val #>              A            B            C            D          E #> A 1.000000e+00 4.651060e-01 8.724085e-01 6.022472e-02 0.88321535 #> B 1.749755e-01 1.000000e+00 2.413209e-01 9.401252e-01 0.06325044 #> C 8.289132e-01 3.259650e-06 1.000000e+00 2.958733e-01 0.43794278 #> D 6.051335e-01 5.089227e-30 4.945655e-01 1.000000e+00 0.15173540 #> E 7.633085e-20 6.462766e-01 5.580378e-18 8.617029e-17 1.00000000 #>  #> $graph #>       A     B     C     D     E #> A FALSE FALSE FALSE FALSE FALSE #> B FALSE FALSE FALSE FALSE FALSE #> C FALSE  TRUE FALSE FALSE FALSE #> D FALSE  TRUE FALSE FALSE FALSE #> E  TRUE  TRUE  TRUE  TRUE FALSE #>  #> $alpha #> [1] 0.05 #>  #> attr(,\"class\") #> [1] \"summary.AncReg\"  #compare true and estimated ancestral graph trueGraph <- igraph::graph_from_adjacency_matrix(recAncestor(B != 0)) ancGraph <- igraph::graph_from_adjacency_matrix(res$graph)  oldpar <- par(mfrow = c(1, 2)) plot(trueGraph, main = 'true ancestral graph', vertex.size = 30) plot(ancGraph, main = 'Ancestor Regression', vertex.size = 30)   ##### SVAR-example with geyser timeseries geyser <- MASS::geyser # shift waiting such that it is waiting after erruption geyser2 <- data.frame(waiting = geyser$waiting[-1], duration = geyser$duration[-nrow(geyser)])  # fit ancestor regression with 6 lags considered fit2 <- AncReg(as.matrix(geyser2), degree = 6) res2 <- summary(fit2) res2 #> $inst.p.val #>            waiting     duration #> waiting  1.0000000 0.0004811719 #> duration 0.5109396 1.0000000000 #>  #> $inst.graph #>          waiting duration #> waiting    FALSE     TRUE #> duration   FALSE    FALSE #>  #> $inst.alpha #> [1] 0.05 #>  #> $sum.p.val #>            waiting    duration #> waiting  1.0000000 0.008733271 #> duration 0.1760936 1.000000000 #>  #> $sum.graph #>          waiting duration #> waiting    FALSE     TRUE #> duration   FALSE    FALSE #>  #> attr(,\"class\") #> [1] \"summary.AncReg\"  # visualize instantaneous ancestry instGraph <- igraph::graph_from_adjacency_matrix(res2$inst.graph) plot(instGraph, edge.label = round(diag(res2$inst.p.val[1:2, 2:1]), 2),      main = 'instantaneous effects', vertex.size = 90)  # visualize summary of lagged ancestry sumGraph <- igraph::graph_from_adjacency_matrix(res2$sum.graph) plot(sumGraph, edge.label = round(diag(res2$sum.p.val[1:2, 2:1]), 2),      main = 'summary graph', vertex.size = 90)  par(oldpar)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Instantaneous graph — instant_graph","title":"Instantaneous graph — instant_graph","text":"Construct instantaneous graph p-values significance level. Recursively constructs ancestral connections adding ancestors ancestors.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Instantaneous graph — instant_graph","text":"","code":"instant_graph(lin.anc, alpha = 0.05, verbose = FALSE, corr = TRUE)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Instantaneous graph — instant_graph","text":"lin.anc output AncReg() alpha significance level verbose information printed? corr multiplicity correction applied?","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Instantaneous graph — instant_graph","text":"list containing: rec.ancs boolean matrix indicating whether one variable affects another instantaneously alpha significance level avoid cycles","code":""},{"path":[]},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Instantaneous graph — instant_graph","text":"","code":"# random DAGS for simulation set.seed(1234)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # solution in terms of noise Bprime <- MASS::ginv(diag(p) - B)  n <- 500 N <- matrix(rexp(n * p), ncol = p) X <- t(Bprime %*% t(N)) colnames(X) <- LETTERS[1:p]  # fit ancestor regression fit <- AncReg(X)  # generate instantaneous graph instant_graph(fit, alpha = 0.01, verbose = TRUE) #> $rec.ancs #>       A     B     C     D     E #> A FALSE FALSE FALSE FALSE FALSE #> B FALSE FALSE FALSE FALSE FALSE #> C FALSE FALSE FALSE FALSE FALSE #> D FALSE FALSE FALSE FALSE FALSE #> E FALSE FALSE FALSE FALSE FALSE #>  #> $alpha #> [1] 0.01 #>"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_p.val.html","id":null,"dir":"Reference","previous_headings":"","what":"P-values for instantaneous graph — instant_p.val","title":"P-values for instantaneous graph — instant_p.val","text":"Collect p-values instantaneous graph.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_p.val.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-values for instantaneous graph — instant_p.val","text":"","code":"instant_p.val(lin.anc)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_p.val.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-values for instantaneous graph — instant_p.val","text":"lin.anc output AncReg()","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_p.val.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-values for instantaneous graph — instant_p.val","text":"numeric matrix p-values instantaneous graph","code":""},{"path":[]},{"path":"http://www.markus-ulmer.ch/AncReg/reference/instant_p.val.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-values for instantaneous graph — instant_p.val","text":"","code":"# random DAGS for simulation set.seed(1234)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # solution in terms of noise Bprime <- MASS::ginv(diag(p) - B)  n <- 500 N <- matrix(rexp(n * p), ncol = p) X <- t(Bprime %*% t(N)) colnames(X) <- LETTERS[1:p]  # fit ancestor regression fit <- AncReg(X)  # collect instantaneous p-values instant_p.val(fit) #>           A           B         C         D         E #> A 1.0000000 0.355083093 0.0493693 0.5107251 0.9777551 #> B 0.6612617 1.000000000 0.5350391 0.1672114 0.5645382 #> C 0.3190314 0.224148437 1.0000000 0.9467940 0.9968308 #> D 0.8740048 0.006213275 0.3530013 1.0000000 0.2938822 #> E 0.4328651 0.798593250 0.4182837 0.1692897 1.0000000"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/recAncestor.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursive Ancestor Detection — recAncestor","title":"Recursive Ancestor Detection — recAncestor","text":"function recursively detects ancestors given set variables matrix. Adds ancestors ancestors output matrix.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/recAncestor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursive Ancestor Detection — recAncestor","text":"","code":"recAncestor(pmat)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/recAncestor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursive Ancestor Detection — recAncestor","text":"pmat boolean matrix indicating whether connection detected.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/recAncestor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursive Ancestor Detection — recAncestor","text":"boolean matrix indicating whether connection detected constructed.","code":""},{"path":[]},{"path":"http://www.markus-ulmer.ch/AncReg/reference/recAncestor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursive Ancestor Detection — recAncestor","text":"","code":"# random DAGS for simulation set.seed(1234)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # edge effects to adjecency matrix B <- B != 0  # transform adjacency matrix to ancestral matrix recAncestor(B) #>       A     B     C     D     E #> A FALSE FALSE FALSE FALSE FALSE #> B FALSE FALSE FALSE FALSE FALSE #> C FALSE  TRUE FALSE FALSE FALSE #> D FALSE  TRUE FALSE FALSE FALSE #> E  TRUE  TRUE  TRUE  TRUE FALSE"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary.AncReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of AncReg — summary.AncReg","title":"Summary of AncReg — summary.AncReg","text":"Summarize results AncReg. models degree = 0 instantaneous graph returned models degree > 0 summary graph returned well.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary.AncReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of AncReg — summary.AncReg","text":"","code":"# S3 method for class 'AncReg' summary(object, alpha = 0.05, verbose = FALSE, corr = TRUE, ...)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary.AncReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of AncReg — summary.AncReg","text":"object output AncReg() alpha significance level determin whether connection significant verbose information printed? corr multiplicity correction applied? ... arguments passed methods.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary.AncReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of AncReg — summary.AncReg","text":"list containing: degree = 0: p.val numeric matrix p-values instantaneous graph graph boolean matrix indicating whether one variable affects another instantaneously alpha significance level avoid cycles degree > 0: inst.p.val numeric matrix p-values instantaneous graph inst.graph boolean matrix indicating whether one variable affects another instantaneously inst.alpha significance level avoid cycles sum.p.val numeric matrix p-values summary graph sum.graph boolean matrix indicating whether one variable affects another","code":""},{"path":[]},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary.AncReg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of AncReg — summary.AncReg","text":"","code":"# random DAGS for simulation set.seed(1234)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # solution in terms of noise Bprime <- MASS::ginv(diag(p) - B)  n <- 500 N <- matrix(rexp(n * p), ncol = p) X <- t(Bprime %*% t(N)) colnames(X) <- LETTERS[1:p]  # fit ancestor regression fit <- AncReg(X) # collect ancestral p-values and graph res <- summary(fit, alpha = 1) res #> $p.val #>           A           B         C         D         E #> A 1.0000000 0.355083093 0.0493693 0.5107251 0.9777551 #> B 0.6612617 1.000000000 0.5350391 0.1672114 0.5645382 #> C 0.3190314 0.224148437 1.0000000 0.9467940 0.9968308 #> D 0.8740048 0.006213275 0.3530013 1.0000000 0.2938822 #> E 0.4328651 0.798593250 0.4182837 0.1692897 1.0000000 #>  #> $graph #>       A     B     C     D     E #> A FALSE FALSE  TRUE FALSE FALSE #> B FALSE FALSE FALSE FALSE FALSE #> C FALSE FALSE FALSE FALSE FALSE #> D FALSE  TRUE FALSE FALSE FALSE #> E FALSE FALSE FALSE FALSE FALSE #>  #> $alpha #> [1] 1 #>  #> attr(,\"class\") #> [1] \"summary.AncReg\""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary graph — summary_graph","title":"Summary graph — summary_graph","text":"Construct summary graph p-values significance level. Recursively constructs ancestral connections adding ancestors ancestors.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary graph — summary_graph","text":"","code":"summary_graph(lin.anc, alpha = 0.05, corr = TRUE)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary graph — summary_graph","text":"lin.anc output AncReg() alpha significance level corr multiplicity correction applied?","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary graph — summary_graph","text":"boolean matrix indicating whether one variable affects another","code":""},{"path":[]},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary graph — summary_graph","text":"","code":"# random DAGS for simulation set.seed(1234)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # solution in terms of noise Bprime <- MASS::ginv(diag(p) - B)  n <- 500 N <- matrix(rexp(n * p), ncol = p) X <- t(Bprime %*% t(N)) colnames(X) <- LETTERS[1:p]  # fit ancestor regression fit <- AncReg(X)  # generate summary graph summary_graph(fit, alpha = 0.1) #>       A     B     C     D     E #> A FALSE FALSE FALSE FALSE FALSE #> B FALSE FALSE FALSE FALSE FALSE #> C FALSE FALSE FALSE FALSE FALSE #> D FALSE FALSE FALSE FALSE FALSE #> E FALSE FALSE FALSE FALSE FALSE"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_p.val.html","id":null,"dir":"Reference","previous_headings":"","what":"P-values for summary graph — summary_p.val","title":"P-values for summary graph — summary_p.val","text":"Collect p-values summary graph.","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_p.val.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-values for summary graph — summary_p.val","text":"","code":"summary_p.val(lin.anc)"},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_p.val.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-values for summary graph — summary_p.val","text":"lin.anc output AncReg()","code":""},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_p.val.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-values for summary graph — summary_p.val","text":"numeric matrix p-values summary graph","code":""},{"path":[]},{"path":"http://www.markus-ulmer.ch/AncReg/reference/summary_p.val.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-values for summary graph — summary_p.val","text":"","code":"# random DAGS for simulation set.seed(1234)  p <- 5 #number of nodes DAG <- pcalg::randomDAG(p, prob = 0.5)  B <- matrix(0, p, p) # represent DAG as matrix for (i in 2:p){   for(j in 1:(i-1)){     # store edge weights     B[i,j] <- max(0, DAG@edgeData@data[[paste(j,\"|\",i, sep=\"\")]]$weight)   } } colnames(B) <- rownames(B) <- LETTERS[1:p]  # solution in terms of noise Bprime <- MASS::ginv(diag(p) - B)  n <- 500 N <- matrix(rexp(n * p), ncol = p) X <- t(Bprime %*% t(N)) colnames(X) <- LETTERS[1:p]  # fit ancestor regression fit <- AncReg(X)  # collect summary p-values summary_p.val(fit) #>           A           B         C         D         E #> A 1.0000000 0.355083093 0.0493693 0.5107251 0.9777551 #> B 0.6612617 1.000000000 0.5350391 0.1672114 0.5645382 #> C 0.3190314 0.224148437 1.0000000 0.9467940 0.9968308 #> D 0.8740048 0.006213275 0.3530013 1.0000000 0.2938822 #> E 0.4328651 0.798593250 0.4182837 0.1692897 1.0000000"},{"path":"http://www.markus-ulmer.ch/AncReg/news/index.html","id":"ancreg-100","dir":"Changelog","previous_headings":"","what":"AncReg 1.0.0","title":"AncReg 1.0.0","text":"Initial CRAN submission.","code":""}]
